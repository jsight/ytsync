// Package ytsync provides a high-level API for YouTube video synchronization.
//
// This package offers convenience functions for the most common operations:
// listing videos, downloading videos, and extracting transcripts.
//
// Example usage:
//
//	ctx := context.Background()
//	videos, err := ytsync.ListVideos(ctx, "https://www.youtube.com/channel/UCxxxxx")
//	if err != nil {
//		log.Fatal(err)
//	}
//	for _, v := range videos {
//		fmt.Println(v.Title)
//	}
package ytsync

import (
	"context"
	"fmt"
	"ytsync/config"
	"ytsync/storage"
	"ytsync/youtube"
)

// ListVideos retrieves videos from a YouTube channel using default configuration.
// It uses the RSS feed by default for fast listing of recent videos.
//
// The channelURL can be:
// - A channel URL: https://www.youtube.com/channel/UCxxxxx
// - A handle: https://www.youtube.com/@channelname
// - A channel ID: UCxxxxx
//
// For full history of all videos, use ListVideosWithOptions with a Ytdlp lister.
func ListVideos(ctx context.Context, channelURL string) ([]youtube.VideoInfo, error) {
	return ListVideosWithOptions(ctx, channelURL, &ListOptions{})
}

// ListOptions configures video listing behavior.
type ListOptions struct {
	// MaxResults limits the number of videos to retrieve (0 = all available)
	MaxResults int
	// UseRSS forces using RSS feed instead of yt-dlp (default: true for efficiency)
	UseRSS bool
	// UseYouTubeAPI forces using YouTube Data API v3 if enabled in config (default: false)
	UseYouTubeAPI bool
	// ContentType specifies what to list: videos, streams, or both (default: videos)
	ContentType youtube.ContentType
}

// ListVideosWithOptions retrieves videos with custom options.
func ListVideosWithOptions(ctx context.Context, channelURL string, opts *ListOptions) ([]youtube.VideoInfo, error) {
	if opts == nil {
		opts = &ListOptions{}
	}

	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		return nil, fmt.Errorf("load config: %w", err)
	}

	// Create lister
	var lister youtube.VideoLister
	if opts.UseYouTubeAPI && cfg.YouTubeAPIEnabled {
		if cfg.YouTubeAPIKey == "" {
			return nil, fmt.Errorf("YouTube API requested but no API key configured")
		}
		apiLister, err := youtube.NewAPILister(cfg.YouTubeAPIKey, cfg.YouTubeAPIQuotaReserve)
		if err != nil {
			return nil, fmt.Errorf("create api lister: %w", err)
		}
		// Set up fallback to yt-dlp when quota exhausted
		ytdlp := youtube.NewYtdlpLister()
		ytdlp.Path = cfg.YtdlpPath
		ytdlp.Timeout = cfg.YtdlpTimeout
		apiLister.SetFallbackLister(ytdlp)
		lister = apiLister
	} else if opts.UseRSS {
		lister = youtube.NewRSSLister()
	} else {
		ytdlp := youtube.NewYtdlpLister()
		ytdlp.Path = cfg.YtdlpPath
		ytdlp.Timeout = cfg.YtdlpTimeout
		lister = ytdlp
	}

	// Build list options
	listOpts := &youtube.ListOptions{
		MaxResults:  opts.MaxResults,
		ContentType: opts.ContentType,
	}

	// List videos
	videos, err := lister.ListVideos(ctx, channelURL, listOpts)
	if err != nil {
		return nil, fmt.Errorf("list videos: %w", err)
	}

	return videos, nil
}

// TranscriptOptions configures transcript extraction.
type TranscriptOptions struct {
	// Languages specifies preferred language codes (e.g., ["en", "es"]).
	// Empty means try all available languages.
	Languages []string
	// SkipAutoGenerated skips auto-generated captions if true.
	SkipAutoGenerated bool
}

// ExtractTranscript retrieves and parses the transcript for a video.
// It returns the first available transcript matching the options.
func ExtractTranscript(ctx context.Context, videoID string) (*youtube.Transcript, error) {
	return ExtractTranscriptWithOptions(ctx, videoID, &TranscriptOptions{})
}

// ExtractTranscriptWithOptions extracts a transcript with custom options.
func ExtractTranscriptWithOptions(ctx context.Context, videoID string, opts *TranscriptOptions) (*youtube.Transcript, error) {
	if opts == nil {
		opts = &TranscriptOptions{}
	}

	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		return nil, fmt.Errorf("load config: %w", err)
	}

	// Create extractor
	extractor := youtube.NewTranscriptExtractor()
	extractor.YtdlpPath = cfg.YtdlpPath
	extractor.Timeout = cfg.YtdlpTimeout

	// Build extract options
	extractOpts := &youtube.ExtractOptions{
		Languages:         opts.Languages,
		Format:            "json3",
		SkipAutoGenerated: opts.SkipAutoGenerated,
	}

	// Extract transcript
	transcript, err := extractor.Extract(ctx, videoID, extractOpts)
	if err != nil {
		return nil, fmt.Errorf("extract transcript: %w", err)
	}

	return transcript, nil
}

// FetchVideoMetadata retrieves comprehensive metadata for a video using yt-dlp.
// This includes title, description, duration, view count, and other details.
func FetchVideoMetadata(ctx context.Context, videoID string) (*youtube.VideoMetadata, error) {
	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		return nil, fmt.Errorf("load config: %w", err)
	}

	// Fetch metadata
	metadata, err := youtube.FetchMetadata(ctx, videoID, cfg.YtdlpPath)
	if err != nil {
		return nil, fmt.Errorf("fetch metadata: %w", err)
	}

	return metadata, nil
}

// SyncOptions configures video synchronization behavior.
type SyncOptions struct {
	// MaxResults limits the number of videos to retrieve (0 = all available)
	MaxResults int
	// ContentType specifies what to list: videos, streams, or both
	ContentType youtube.ContentType
	// StorePath is the path to the JSON store for persisting sync state
	// Required for incremental sync functionality
	StorePath string
}

// SyncChannelVideos performs an efficient incremental sync of channel videos.
// It uses the sync manager to coordinate between RSS (fast, incremental) and
// full sync strategies. Sync state is persisted to enable gap detection and
// resumable pagination.
//
// Returns a SyncResult containing the videos discovered and metadata about the sync.
func SyncChannelVideos(ctx context.Context, channelURL string, opts *SyncOptions) (*SyncResult, error) {
	if opts == nil {
		opts = &SyncOptions{}
	}

	if opts.StorePath == "" {
		return nil, fmt.Errorf("StorePath is required for sync operations")
	}

	// Initialize storage
	store, err := storage.NewJSONStore(opts.StorePath)
	if err != nil {
		return nil, fmt.Errorf("initialize store: %w", err)
	}
	defer store.Close()

	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		return nil, fmt.Errorf("load config: %w", err)
	}

	// Create fallback lister (for full syncs when RSS has gaps)
	fallback := youtube.NewYtdlpLister()
	fallback.Path = cfg.YtdlpPath
	fallback.Timeout = cfg.YtdlpTimeout

	// Create sync manager
	rssLister := youtube.NewRSSLister()
	syncMgr := youtube.NewSyncManagerWithListers(rssLister, fallback, store)

	// Build list options
	listOpts := &youtube.ListOptions{
		MaxResults:  opts.MaxResults,
		ContentType: opts.ContentType,
	}

	// Perform sync
	result, err := syncMgr.SyncChannelVideos(ctx, channelURL, listOpts)
	if err != nil {
		return nil, fmt.Errorf("sync channel videos: %w", err)
	}

	// Convert to public result type
	return &SyncResult{
		Videos:         result.Videos,
		NewVideosCount: result.NewVideosCount,
		IsIncremental:  result.IsIncremental,
		IsFullSync:     result.IsFullSync,
		GapDetected:    result.GapDetected,
	}, nil
}

// SyncResult contains the outcome of a sync operation.
type SyncResult struct {
	// Videos is the list of videos discovered during this sync.
	Videos []youtube.VideoInfo
	// NewVideosCount is the number of new videos discovered.
	NewVideosCount int
	// IsIncremental is true if this was an incremental sync.
	IsIncremental bool
	// IsFullSync is true if this was a full sync.
	IsFullSync bool
	// GapDetected is true if RSS sync detected a gap in the feed.
	GapDetected bool
}

// DownloadOptions configures video download behavior.
type DownloadOptions struct {
	// OutputDir is the directory to save the downloaded video.
	// Defaults to current directory if empty.
	OutputDir string
	// Format specifies the video format: "best", "mp4", "webm", or a yt-dlp format string.
	// Defaults to "best" which selects the best quality up to 1080p.
	Format string
	// AudioOnly extracts audio as MP3 instead of downloading video.
	AudioOnly bool
	// AudioQuality specifies the audio quality in kbps when AudioOnly is true.
	// Defaults to 192 if not specified.
	AudioQuality int
	// IncludeMetadata saves video metadata to a JSON file alongside the video.
	IncludeMetadata bool
	// Filename specifies a custom output filename (without extension).
	// If empty, defaults to the sanitized video title.
	// When provided, this takes precedence over title-based naming.
	// Useful for ensuring unique filenames based on video IDs (e.g., "dQw4w9WgXcQ").
	Filename string
}

// DownloadResult contains information about a completed download.
type DownloadResult struct {
	// VideoPath is the path to the downloaded video/audio file.
	VideoPath string
	// MetadataPath is the path to the metadata JSON file (if IncludeMetadata was true).
	MetadataPath string
	// Metadata contains the parsed video metadata (if IncludeMetadata was true).
	Metadata *youtube.VideoMetadata
}

// DownloadVideo downloads a YouTube video using default configuration.
// It uses yt-dlp to download the video in the best available quality up to 1080p.
//
// The videoID can be:
// - A video ID: dQw4w9WgXcQ
// - A full URL: https://www.youtube.com/watch?v=dQw4w9WgXcQ
//
// The video will be saved to the current directory with the video's title as filename.
func DownloadVideo(ctx context.Context, videoID string) (*DownloadResult, error) {
	return DownloadVideoWithOptions(ctx, videoID, &DownloadOptions{})
}

// DownloadVideoWithOptions downloads a YouTube video with custom options.
func DownloadVideoWithOptions(ctx context.Context, videoID string, opts *DownloadOptions) (*DownloadResult, error) {
	if opts == nil {
		opts = &DownloadOptions{}
	}

	// Load configuration
	cfg, err := config.Load()
	if err != nil {
		return nil, fmt.Errorf("load config: %w", err)
	}

	// Create downloader
	downloader := youtube.NewDownloader()
	downloader.YtdlpPath = cfg.YtdlpPath

	// Convert public options to internal options
	downloadOpts := &youtube.DownloadOptions{
		OutputDir:       opts.OutputDir,
		Format:          opts.Format,
		AudioOnly:       opts.AudioOnly,
		AudioQuality:    opts.AudioQuality,
		IncludeMetadata: opts.IncludeMetadata,
		Filename:        opts.Filename,
		YtdlpPath:       cfg.YtdlpPath,
	}

	// Download video
	result, err := downloader.Download(ctx, videoID, downloadOpts)
	if err != nil {
		return nil, fmt.Errorf("download video: %w", err)
	}

	// Convert result to public type
	return &DownloadResult{
		VideoPath:    result.VideoPath,
		MetadataPath: result.MetadataPath,
		Metadata:     result.Metadata,
	}, nil
}
