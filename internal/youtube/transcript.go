// Package youtube provides transcript extraction.
package youtube

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"os/exec"
	"strings"
	"time"
	"ytsync/internal/retry"
)

// TranscriptExtractor provides transcript extraction functionality.
type TranscriptExtractor struct {
	// YtdlpPath is the path to the yt-dlp executable.
	YtdlpPath string
	// Timeout is the maximum time to wait for yt-dlp.
	Timeout time.Duration
	// RetryConfig holds retry behavior configuration.
	RetryConfig *retry.Config
}

// NewTranscriptExtractor creates a new transcript extractor.
func NewTranscriptExtractor() *TranscriptExtractor {
	cfg := retry.DefaultConfig()
	return &TranscriptExtractor{
		YtdlpPath:   "yt-dlp",
		Timeout:     5 * time.Minute,
		RetryConfig: &cfg,
	}
}

// TranscriptEntry represents a single line in a transcript.
type TranscriptEntry struct {
	// Start is the start time in seconds.
	Start float64 `json:"start"`
	// Duration is how long the entry lasts in seconds.
	Duration float64 `json:"duration"`
	// Text is the transcript text.
	Text string `json:"text"`
}

// Transcript contains the full transcript for a video.
type Transcript struct {
	// VideoID is the YouTube video ID.
	VideoID string `json:"video_id"`
	// Language is the ISO 639-1 language code (e.g., "en", "es").
	Language string `json:"language"`
	// LanguageName is the human-readable language name.
	LanguageName string `json:"language_name"`
	// IsAutoGenerated indicates if this is an auto-generated transcript.
	IsAutoGenerated bool `json:"is_auto_generated"`
	// Entries is the list of transcript entries.
	Entries []TranscriptEntry `json:"entries"`
	// DownloadURL is the URL where the transcript can be downloaded (e.g., JSON3 format).
	DownloadURL string `json:"download_url,omitempty"`
}

// ExtractOptions configures transcript extraction.
type ExtractOptions struct {
	// Languages is a list of language codes to try (e.g., ["en", "es"]).
	// Empty list means all available languages.
	Languages []string
	// Format specifies output format: "json3", "vtt", "srt", "txt".
	Format string
	// SkipAutoGenerated skips auto-generated captions if set.
	SkipAutoGenerated bool
}

// Extract fetches and parses the transcript for a video.
func (te *TranscriptExtractor) Extract(ctx context.Context, videoID string, opts *ExtractOptions) (*Transcript, error) {
	if opts == nil {
		opts = &ExtractOptions{Format: "json3"}
	}
	if opts.Format == "" {
		opts.Format = "json3"
	}

	cfg := te.RetryConfig
	if cfg == nil {
		defaultCfg := retry.DefaultConfig()
		cfg = &defaultCfg
	}

	var transcript *Transcript
	err := retry.Do(ctx, *cfg, transcriptErrorClassifier, func(ctx context.Context) error {
		// Build yt-dlp arguments to get subtitle info
		args := []string{
			"--skip-download",
			"--all-subs", // Get all available subtitles
			"-J",         // JSON output for metadata
			"--no-warnings",
		}

		// Add language filter if specified
		if len(opts.Languages) > 0 {
			args = append(args, fmt.Sprintf("--sub-langs=%s", strings.Join(opts.Languages, ",")))
		}

		// Add auto-generated skip if requested
		if opts.SkipAutoGenerated {
			args = append(args, "--skip-automatic-captions")
		}

		args = append(args, videoID)

		// Create command with timeout
		timeout := te.Timeout
		if timeout == 0 {
			timeout = 5 * time.Minute
		}
		cmdCtx, cancel := context.WithTimeout(ctx, timeout)
		defer cancel()

		cmd := exec.CommandContext(cmdCtx, te.path(), args...)

		var stdout, stderr bytes.Buffer
		cmd.Stdout = &stdout
		cmd.Stderr = &stderr

		err := cmd.Run()
		if err != nil {
			if cmdCtx.Err() == context.DeadlineExceeded {
				return &TranscriptError{VideoID: videoID, Err: ErrNetworkTimeout}
			}
			if cmdCtx.Err() == context.Canceled {
				return &TranscriptError{VideoID: videoID, Err: context.Canceled}
			}

			// Check for common error patterns
			errMsg := stderr.String()
			if strings.Contains(errMsg, "not found") || strings.Contains(errMsg, "does not exist") {
				return &TranscriptError{VideoID: videoID, Err: ErrChannelNotFound}
			}
			if strings.Contains(errMsg, "no subtitles") || strings.Contains(errMsg, "no captions") {
				return &TranscriptError{VideoID: videoID, Err: ErrNoTranscript}
			}

			return &TranscriptError{VideoID: videoID,
				Err: fmt.Errorf("yt-dlp failed: %w: %s", err, errMsg)}
		}

		// Parse yt-dlp JSON output for video metadata including subtitles
		var info ytdlpVideoInfo
		if err := json.Unmarshal(stdout.Bytes(), &info); err != nil {
			return &TranscriptError{VideoID: videoID, Err: fmt.Errorf("parse yt-dlp output: %w", err)}
		}

		// Extract first available subtitle in requested format
		t, err := te.extractTranscript(&info, videoID, opts)
		if err != nil {
			return err
		}
		transcript = t
		return nil
	})

	return transcript, err
}

// extractTranscript extracts transcript from yt-dlp video info.
func (te *TranscriptExtractor) extractTranscript(info *ytdlpVideoInfo, videoID string, opts *ExtractOptions) (*Transcript, error) {
	if len(info.Subtitles) == 0 && len(info.AutomaticCaptions) == 0 {
		return nil, &TranscriptError{VideoID: videoID, Err: ErrNoTranscript}
	}

	// Try regular subtitles first, then automatic captions
	var langKey string
	var isAutoGenerated bool

	// Prefer requested language
	if len(opts.Languages) > 0 {
		for _, lang := range opts.Languages {
			if _, ok := info.Subtitles[lang]; ok {
				langKey = lang
				break
			}
			if !opts.SkipAutoGenerated {
				if _, ok := info.AutomaticCaptions[lang]; ok {
					langKey = lang
					isAutoGenerated = true
					break
				}
			}
		}
	}

	// Fall back to first available
	if langKey == "" {
		for lang := range info.Subtitles {
			langKey = lang
			break
		}
	}
	if langKey == "" && !opts.SkipAutoGenerated {
		for lang := range info.AutomaticCaptions {
			langKey = lang
			isAutoGenerated = true
			break
		}
	}

	if langKey == "" {
		return nil, &TranscriptError{VideoID: videoID, Err: ErrNoTranscript}
	}

	// Get the subtitle data
	var subtitleData []subtitleFormat
	if isAutoGenerated {
		subtitleData = info.AutomaticCaptions[langKey]
	} else {
		subtitleData = info.Subtitles[langKey]
	}

	// Find JSON format if available and download it
	var entries []TranscriptEntry
	var downloadURL string
	for _, sub := range subtitleData {
		if sub.Ext == "json3" {
			downloadURL = sub.URL
			// Try to download and parse the transcript
			parsedEntries, err := te.downloadTranscript(sub.URL)
			if err == nil {
				entries = parsedEntries
			}
			// If download fails, we'll just return empty entries
			break
		}
	}

	return &Transcript{
		VideoID:         videoID,
		Language:        langKey,
		LanguageName:    getLanguageName(langKey),
		IsAutoGenerated: isAutoGenerated,
		Entries:         entries,
		DownloadURL:     downloadURL,
	}, nil
}

// downloadTranscript downloads and parses a transcript from the YouTube API.
func (te *TranscriptExtractor) downloadTranscript(url string) ([]TranscriptEntry, error) {
	// Fetch the transcript data
	resp, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("download transcript: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("download transcript: HTTP %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("read transcript: %w", err)
	}

	// Parse JSON3 format
	var result struct {
		Events []struct {
			TStart   int64  `json:"tStartMs"`
			Duration int64  `json:"dDurationMs"`
			Segs     []struct {
				Text string `json:"utf8"`
			} `json:"segs"`
		} `json:"events"`
	}

	if err := json.Unmarshal(body, &result); err != nil {
		return nil, fmt.Errorf("parse transcript JSON: %w", err)
	}

	// Convert to transcript entries
	var entries []TranscriptEntry
	for _, event := range result.Events {
		// Build text from segments
		var text strings.Builder
		for _, seg := range event.Segs {
			text.WriteString(seg.Text)
		}

		entry := TranscriptEntry{
			Start:    float64(event.TStart) / 1000.0, // Convert ms to seconds
			Duration: float64(event.Duration) / 1000.0,
			Text:     text.String(),
		}
		entries = append(entries, entry)
	}

	return entries, nil
}

// getLanguageName returns the display name for a language code.
func getLanguageName(code string) string {
	// Common language codes to names
	names := map[string]string{
		"en": "English",
		"es": "Spanish",
		"fr": "French",
		"de": "German",
		"it": "Italian",
		"pt": "Portuguese",
		"ja": "Japanese",
		"zh": "Chinese",
		"ko": "Korean",
		"ru": "Russian",
		"ar": "Arabic",
		"hi": "Hindi",
	}
	if name, ok := names[code]; ok {
		return name
	}
	return code
}

func (te *TranscriptExtractor) path() string {
	if te.YtdlpPath != "" {
		return te.YtdlpPath
	}
	return "yt-dlp"
}

// ytdlpVideoInfo is the yt-dlp output with subtitle information.
type ytdlpVideoInfo struct {
	ID                string                      `json:"id"`
	Subtitles         map[string][]subtitleFormat `json:"subtitles"`
	AutomaticCaptions map[string][]subtitleFormat `json:"automatic_captions"`
}

// subtitleFormat describes a subtitle/caption format.
type subtitleFormat struct {
	URL string `json:"url"`
	Ext string `json:"ext"`
}

// TranscriptError wraps transcript extraction errors.
type TranscriptError struct {
	VideoID string
	Err     error
}

func (e *TranscriptError) Error() string {
	return fmt.Sprintf("transcript %s: %v", e.VideoID, e.Err)
}

func (e *TranscriptError) Unwrap() error {
	return e.Err
}

// ErrNoTranscript indicates the video has no available transcripts.
var ErrNoTranscript = fmt.Errorf("youtube: no transcript available")

// transcriptErrorClassifier determines if a transcript error is retryable.
func transcriptErrorClassifier(err error) bool {
	if err == nil {
		return false
	}

	// Check for permanent errors
	var transcriptErr *TranscriptError
	if errors.As(err, &transcriptErr) {
		switch transcriptErr.Err {
		case ErrChannelNotFound, ErrNoTranscript, ErrInvalidURL:
			return false
		default:
			return true
		}
	}

	return true
}
