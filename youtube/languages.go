package youtube

import (
	"fmt"
	"sync"
	"time"
)

// LanguagePreference defines how to select languages for transcript extraction.
type LanguagePreference struct {
	// Preferred languages in order of preference (e.g., ["en", "es", "fr"])
	PreferredLanguages []string

	// IncludeAutoGenerated includes auto-generated captions in selection
	IncludeAutoGenerated bool

	// AllowEnglishFallback automatically includes English if preferred languages not found
	AllowEnglishFallback bool

	// PreferManualCaptions prefers manually created captions over auto-generated
	PreferManualCaptions bool
}

// DefaultLanguagePreference returns sensible language preferences.
func DefaultLanguagePreference() LanguagePreference {
	return LanguagePreference{
		PreferredLanguages:   []string{"en"},
		IncludeAutoGenerated: true,
		AllowEnglishFallback: true,
		PreferManualCaptions: true,
	}
}

// LanguageAvailability describes available languages for a video.
type LanguageAvailability struct {
	VideoID          string
	ManualLanguages  []LanguageInfo    // Manually created captions
	AutoLanguages    []LanguageInfo    // Auto-generated captions
	lastUpdated      time.Time
	mu               sync.RWMutex
}

// NewLanguageAvailability creates a new language availability tracker.
func NewLanguageAvailability(videoID string) *LanguageAvailability {
	return &LanguageAvailability{
		VideoID:         videoID,
		ManualLanguages: []LanguageInfo{},
		AutoLanguages:   []LanguageInfo{},
	}
}

// Update updates the available languages for the video.
func (la *LanguageAvailability) Update(manual, auto []LanguageInfo) {
	la.mu.Lock()
	defer la.mu.Unlock()
	la.ManualLanguages = manual
	la.AutoLanguages = auto
	la.lastUpdated = time.Now()
}

// SelectLanguage selects the best language based on preferences.
// Returns the selected language code and whether it's auto-generated.
func (la *LanguageAvailability) SelectLanguage(pref LanguagePreference) (string, bool) {
	la.mu.RLock()
	defer la.mu.RUnlock()

	// Try preferred languages first
	for _, prefLang := range pref.PreferredLanguages {
		// Check manual captions first if preference is set
		if pref.PreferManualCaptions {
			if langInfo := la.findLanguage(prefLang, la.ManualLanguages); langInfo != nil {
				return langInfo.Code, false
			}
		}

		// Check auto-generated if allowed
		if pref.IncludeAutoGenerated {
			if langInfo := la.findLanguage(prefLang, la.AutoLanguages); langInfo != nil {
				return langInfo.Code, true
			}
		}

		// If we don't prefer manual captions, check them second
		if !pref.PreferManualCaptions {
			if langInfo := la.findLanguage(prefLang, la.ManualLanguages); langInfo != nil {
				return langInfo.Code, false
			}
		}
	}

	// Fallback to English if allowed
	if pref.AllowEnglishFallback {
		if pref.PreferManualCaptions {
			if langInfo := la.findLanguage("en", la.ManualLanguages); langInfo != nil {
				return langInfo.Code, false
			}
		}

		if pref.IncludeAutoGenerated {
			if langInfo := la.findLanguage("en", la.AutoLanguages); langInfo != nil {
				return langInfo.Code, true
			}
		}

		if !pref.PreferManualCaptions {
			if langInfo := la.findLanguage("en", la.ManualLanguages); langInfo != nil {
				return langInfo.Code, false
			}
		}
	}

	// Last resort: return any available language
	if len(la.ManualLanguages) > 0 {
		return la.ManualLanguages[0].Code, false
	}
	if len(la.AutoLanguages) > 0 {
		return la.AutoLanguages[0].Code, true
	}

	return "", false
}

// findLanguage searches for a language in the list by code.
func (la *LanguageAvailability) findLanguage(code string, languages []LanguageInfo) *LanguageInfo {
	for i, lang := range languages {
		if lang.Code == code {
			return &languages[i]
		}
	}
	return nil
}

// GetAllLanguages returns all available languages (manual + auto).
func (la *LanguageAvailability) GetAllLanguages() []LanguageInfo {
	la.mu.RLock()
	defer la.mu.RUnlock()

	all := make([]LanguageInfo, 0, len(la.ManualLanguages)+len(la.AutoLanguages))
	all = append(all, la.ManualLanguages...)

	// Add auto languages that aren't already in manual
	for _, auto := range la.AutoLanguages {
		if !la.hasLanguage(auto.Code, la.ManualLanguages) {
			all = append(all, auto)
		}
	}

	return all
}

// hasLanguage checks if a language code exists in a list.
func (la *LanguageAvailability) hasLanguage(code string, languages []LanguageInfo) bool {
	for _, lang := range languages {
		if lang.Code == code {
			return true
		}
	}
	return false
}

// LanguageCache caches language availability for multiple videos.
type LanguageCache struct {
	cache map[string]*LanguageAvailability
	mu    sync.RWMutex
	ttl   time.Duration
}

// NewLanguageCache creates a new language availability cache.
// ttl specifies how long cached data is valid (0 = no expiration).
func NewLanguageCache(ttl time.Duration) *LanguageCache {
	return &LanguageCache{
		cache: make(map[string]*LanguageAvailability),
		ttl:   ttl,
	}
}

// Get retrieves cached language availability for a video.
// Returns nil if not cached or cache expired.
func (lc *LanguageCache) Get(videoID string) *LanguageAvailability {
	lc.mu.RLock()
	defer lc.mu.RUnlock()

	la, ok := lc.cache[videoID]
	if !ok {
		return nil
	}

	// Check if cache expired
	if lc.ttl > 0 && time.Since(la.lastUpdated) > lc.ttl {
		return nil
	}

	return la
}

// Set stores language availability in the cache.
func (lc *LanguageCache) Set(videoID string, availability *LanguageAvailability) {
	lc.mu.Lock()
	defer lc.mu.Unlock()
	lc.cache[videoID] = availability
}

// Clear removes an entry from the cache.
func (lc *LanguageCache) Clear(videoID string) {
	lc.mu.Lock()
	defer lc.mu.Unlock()
	delete(lc.cache, videoID)
}

// ClearAll removes all entries from the cache.
func (lc *LanguageCache) ClearAll() {
	lc.mu.Lock()
	defer lc.mu.Unlock()
	lc.cache = make(map[string]*LanguageAvailability)
}

// Size returns the current size of the cache.
func (lc *LanguageCache) Size() int {
	lc.mu.RLock()
	defer lc.mu.RUnlock()
	return len(lc.cache)
}

// LanguageSelector combines language availability and preference selection.
type LanguageSelector struct {
	cache      *LanguageCache
	preference LanguagePreference
}

// NewLanguageSelector creates a new language selector.
func NewLanguageSelector(pref LanguagePreference) *LanguageSelector {
	return &LanguageSelector{
		cache:      NewLanguageCache(24 * time.Hour), // Cache for 24 hours
		preference: pref,
	}
}

// Select selects the best language for a video based on available languages.
// It uses the preference logic and caches the result.
func (ls *LanguageSelector) Select(videoID string, available *LanguageAvailability) (string, bool, error) {
	if videoID == "" {
		return "", false, fmt.Errorf("video ID is required")
	}
	if available == nil {
		return "", false, fmt.Errorf("language availability is required")
	}

	// Store in cache
	ls.cache.Set(videoID, available)

	// Select language based on preference
	lang, isAuto := available.SelectLanguage(ls.preference)

	if lang == "" {
		return "", false, fmt.Errorf("no available languages for video %s", videoID)
	}

	return lang, isAuto, nil
}

// GetCachedLanguages retrieves cached language information for a video.
func (ls *LanguageSelector) GetCachedLanguages(videoID string) *LanguageAvailability {
	return ls.cache.Get(videoID)
}

// ClearCache clears the language cache.
func (ls *LanguageSelector) ClearCache() {
	ls.cache.ClearAll()
}

// LanguageInfo constants for common languages.
var (
	LangEnglish    = LanguageInfo{Code: "en", Name: "English"}
	LangSpanish    = LanguageInfo{Code: "es", Name: "Spanish"}
	LangFrench     = LanguageInfo{Code: "fr", Name: "French"}
	LangGerman     = LanguageInfo{Code: "de", Name: "German"}
	LangItalian    = LanguageInfo{Code: "it", Name: "Italian"}
	LangPortuguese = LanguageInfo{Code: "pt", Name: "Portuguese"}
	LangJapanese   = LanguageInfo{Code: "ja", Name: "Japanese"}
	LangChinese    = LanguageInfo{Code: "zh", Name: "Chinese"}
	LangKorean     = LanguageInfo{Code: "ko", Name: "Korean"}
	LangRussian    = LanguageInfo{Code: "ru", Name: "Russian"}
	LangArabic     = LanguageInfo{Code: "ar", Name: "Arabic"}
	LangHindi      = LanguageInfo{Code: "hi", Name: "Hindi"}
)

// GetLanguageInfo returns language information for a language code.
func GetLanguageInfo(code string) LanguageInfo {
	info := map[string]LanguageInfo{
		"en": LangEnglish,
		"es": LangSpanish,
		"fr": LangFrench,
		"de": LangGerman,
		"it": LangItalian,
		"pt": LangPortuguese,
		"ja": LangJapanese,
		"zh": LangChinese,
		"ko": LangKorean,
		"ru": LangRussian,
		"ar": LangArabic,
		"hi": LangHindi,
	}

	if langInfo, ok := info[code]; ok {
		return langInfo
	}

	return LanguageInfo{Code: code, Name: code}
}
