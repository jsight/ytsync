package youtube

import (
	"testing"
)

// TestTranscriptExtractionMultipleLanguages tests that the system correctly
// handles videos with multiple available languages and respects language preferences.
func TestTranscriptExtractionMultipleLanguages(t *testing.T) {
	// This test demonstrates the language selection system.
	// In a real scenario, this would test against actual YouTube videos.

	// Set up a mock language availability
	la := NewLanguageAvailability("dQw4w9WgXcQ") // Example video ID

	// Simulating multiple language availability
	manual := []LanguageInfo{
		{Code: "en", Name: "English", IsAutoGenerated: false},
		{Code: "es", Name: "Spanish", IsAutoGenerated: false},
		{Code: "fr", Name: "French", IsAutoGenerated: false},
	}

	auto := []LanguageInfo{
		{Code: "de", Name: "German", IsAutoGenerated: true},
		{Code: "ja", Name: "Japanese", IsAutoGenerated: true},
	}

	la.Update(manual, auto)

	// Test 1: English preference
	pref := LanguagePreference{
		PreferredLanguages:   []string{"en"},
		PreferManualCaptions: true,
		IncludeAutoGenerated: false,
	}

	lang, isAuto := la.SelectLanguage(pref)
	if lang != "en" || isAuto {
		t.Errorf("English preference: got %s (auto=%v), want en (auto=false)", lang, isAuto)
	}

	// Test 2: Spanish preference
	pref.PreferredLanguages = []string{"es"}
	lang, isAuto = la.SelectLanguage(pref)
	if lang != "es" || isAuto {
		t.Errorf("Spanish preference: got %s (auto=%v), want es (auto=false)", lang, isAuto)
	}

	// Test 3: Non-existent language fallback
	pref.PreferredLanguages = []string{"it"} // Italian not available
	pref.AllowEnglishFallback = true
	lang, isAuto = la.SelectLanguage(pref)
	if lang != "en" || isAuto {
		t.Errorf("Fallback: got %s (auto=%v), want en (auto=false)", lang, isAuto)
	}

	// Test 4: Auto-generated as fallback
	pref.PreferredLanguages = []string{"de"}
	pref.IncludeAutoGenerated = true
	lang, isAuto = la.SelectLanguage(pref)
	if lang != "de" || !isAuto {
		t.Errorf("Auto-generated fallback: got %s (auto=%v), want de (auto=true)", lang, isAuto)
	}
}

// TestTranscriptExtractionManualVsAutoGenerated tests that manual captions
// are correctly preferred over auto-generated ones when requested.
func TestTranscriptExtractionManualVsAutoGenerated(t *testing.T) {
	la := NewLanguageAvailability("test-video")

	// Both manual and auto-generated English available
	manual := []LanguageInfo{
		{Code: "en", Name: "English", IsAutoGenerated: false},
	}
	auto := []LanguageInfo{
		{Code: "en", Name: "English (auto)", IsAutoGenerated: true},
	}
	la.Update(manual, auto)

	// Test: Prefer manual captions
	pref := LanguagePreference{
		PreferredLanguages:   []string{"en"},
		PreferManualCaptions: true,
		IncludeAutoGenerated: true,
	}

	_, isAuto := la.SelectLanguage(pref)
	if isAuto {
		t.Error("Should prefer manual captions over auto-generated")
	}

	// Test: Allow auto-generated if no manual
	la.Update([]LanguageInfo{}, auto) // Remove manual

	lang, isAuto := la.SelectLanguage(pref)
	if lang != "en" || !isAuto {
		t.Errorf("Should fallback to auto-generated: got %s (auto=%v)", lang, isAuto)
	}
}

// TestTranscriptExtractionLanguageFallback tests that the system correctly
// falls back through language preferences when preferred languages are not available.
func TestTranscriptExtractionLanguageFallback(t *testing.T) {
	la := NewLanguageAvailability("test-video")

	manual := []LanguageInfo{
		{Code: "en", Name: "English"},
		{Code: "es", Name: "Spanish"},
		{Code: "fr", Name: "French"},
	}
	la.Update(manual, []LanguageInfo{})

	// Test: Fallback chain
	pref := LanguagePreference{
		PreferredLanguages:   []string{"ja", "de", "es"}, // ja and de not available
		PreferManualCaptions: true,
	}

	lang, _ := la.SelectLanguage(pref)
	if lang != "es" {
		t.Errorf("Fallback chain: got %s, want es (first available in preference list)", lang)
	}

	// Test: Ultimate English fallback
	pref.PreferredLanguages = []string{"ja", "de", "it"} // None available
	pref.AllowEnglishFallback = true
	lang, _ = la.SelectLanguage(pref)
	if lang != "en" {
		t.Errorf("English fallback: got %s, want en", lang)
	}
}

// TestLanguageAvailabilityDetection tests that language availability
// is correctly detected and cached.
func TestLanguageAvailabilityDetection(t *testing.T) {
	selector := NewLanguageSelector(DefaultLanguagePreference())

	// Create availability info
	la := NewLanguageAvailability("test-video")
	manual := []LanguageInfo{
		{Code: "en", Name: "English"},
		{Code: "es", Name: "Spanish"},
	}
	auto := []LanguageInfo{
		{Code: "fr", Name: "French (auto)"},
	}
	la.Update(manual, auto)

	// Select language
	_, _, err := selector.Select("test-video", la)
	if err != nil {
		t.Fatalf("Select failed: %v", err)
	}

	// Verify cache
	cached := selector.GetCachedLanguages("test-video")
	if cached == nil {
		t.Fatal("Language availability should be cached")
	}

	allLangs := cached.GetAllLanguages()
	if len(allLangs) != 3 {
		t.Errorf("GetAllLanguages returned %d languages, want 3", len(allLangs))
	}
}

// TestLanguageCachePerformance tests that language caching improves performance
// by avoiding redundant API calls.
func TestLanguageCachePerformance(t *testing.T) {
	cache := NewLanguageCache(0) // No TTL

	// First call - cache miss
	la1 := NewLanguageAvailability("video-1")
	la1.Update(
		[]LanguageInfo{{Code: "en", Name: "English"}},
		[]LanguageInfo{},
	)
	cache.Set("video-1", la1)

	// Second call - cache hit
	la1Cached := cache.Get("video-1")
	if la1Cached == nil {
		t.Fatal("Cache should return previously stored value")
	}

	if la1Cached.VideoID != la1.VideoID {
		t.Errorf("Cached object mismatch: %s != %s", la1Cached.VideoID, la1.VideoID)
	}

	// Verify it's the same object
	if len(la1Cached.ManualLanguages) != 1 {
		t.Error("Cached language data should be preserved")
	}
}

// TestTranscriptExtractionEdgeCases tests edge cases in transcript extraction
// such as empty transcript lists and special characters.
func TestTranscriptExtractionEdgeCases(t *testing.T) {
	// Test 1: Empty language availability
	la := NewLanguageAvailability("test-video")
	la.Update([]LanguageInfo{}, []LanguageInfo{})

	pref := DefaultLanguagePreference()
	lang, _ := la.SelectLanguage(pref)
	if lang != "" {
		t.Errorf("Should return empty string for no available languages, got %s", lang)
	}

	// Test 2: Special characters in language info
	la.Update(
		[]LanguageInfo{
			{Code: "zh-Hans", Name: "Chinese (Simplified)"},
			{Code: "pt-BR", Name: "Portuguese (Brazil)"},
		},
		[]LanguageInfo{},
	)

	lang, _ = la.SelectLanguage(LanguagePreference{
		PreferredLanguages: []string{"zh-Hans"},
	})
	if lang != "zh-Hans" {
		t.Errorf("Should handle language codes with hyphens, got %s", lang)
	}

	// Test 3: Language not found with strict preference
	la.Update(
		[]LanguageInfo{{Code: "en", Name: "English"}},
		[]LanguageInfo{},
	)

	pref = LanguagePreference{
		PreferredLanguages:   []string{"fr"},
		AllowEnglishFallback: false,
	}
	lang, _ = la.SelectLanguage(pref)
	if lang != "en" { // Falls back to first available, not English
		t.Errorf("With fallback disabled, should return first available: got %s", lang)
	}
}

// TestTranscriptExtractionFormatConversion tests that extracted transcripts
// can be converted to various formats correctly.
func TestTranscriptExtractionFormatConversion(t *testing.T) {
	// Create sample transcript entries
	entries := []TranscriptEntry{
		{Start: 0, Duration: 2, Text: "Hello world"},
		{Start: 2, Duration: 2, Text: "This is a test"},
		{Start: 4, Duration: 2, Text: "With special chars: <>&\"'"},
	}

	converter := NewFormatConverter(entries)

	// Test all formats convert without error
	formats := []Format{
		FormatJSON3,
		FormatJSON,
		FormatVTT,
		FormatSRT,
		FormatTTML,
		FormatPlainText,
	}

	for _, format := range formats {
		output, err := converter.ToFormat(format)
		if err != nil {
			t.Errorf("ToFormat(%s) failed: %v", format, err)
			continue
		}

		if output == "" {
			t.Errorf("ToFormat(%s) returned empty output", format)
		}

		// Verify content is present
		if format != FormatPlainText {
			// Non-plaintext formats should contain structured data
			if len(output) < 10 {
				t.Errorf("ToFormat(%s) output too short: %s", format, output)
			}
		}
	}
}

// TestMultiLanguagePreferenceChain tests complex preference chains with
// multiple fallback options.
func TestMultiLanguagePreferenceChain(t *testing.T) {
	la := NewLanguageAvailability("test-video")

	// Available languages
	manual := []LanguageInfo{
		{Code: "en", Name: "English"},
		{Code: "es", Name: "Spanish"},
	}
	auto := []LanguageInfo{
		{Code: "en", Name: "English (auto)"},
		{Code: "fr", Name: "French (auto)"},
	}
	la.Update(manual, auto)

	// Complex preference: prefer manual, include auto, with es higher priority
	pref := LanguagePreference{
		PreferredLanguages:   []string{"es", "en", "fr"},
		PreferManualCaptions: true,
		IncludeAutoGenerated: true,
		AllowEnglishFallback: true,
	}

	lang, isAuto := la.SelectLanguage(pref)

	// Should prefer es (available manual) over en (available auto)
	if lang != "es" {
		t.Errorf("Complex preference: got %s, want es", lang)
	}
	if isAuto {
		t.Error("Should select manual es, not auto")
	}

	// Now test when es is not available - should fallback to en manual
	la.Update([]LanguageInfo{{Code: "en", Name: "English"}}, auto)

	lang, isAuto = la.SelectLanguage(pref)
	if lang != "en" || isAuto {
		t.Errorf("After removing es: got %s (auto=%v), want en (auto=false)", lang, isAuto)
	}
}
