package youtube

import (
	"context"
	"testing"
)

func TestNewTimedtextClient(t *testing.T) {
	client := NewTimedtextClient()
	if client == nil {
		t.Fatal("NewTimedtextClient returned nil")
	}
	defer client.Close()

	if client.baseURL != "https://www.youtube.com/api/timedtext" {
		t.Errorf("baseURL = %s, want https://www.youtube.com/api/timedtext", client.baseURL)
	}
}

func TestParseTimedtext(t *testing.T) {
	client := NewTimedtextClient()
	defer client.Close()

	// Test data representing a minimal timedtext response
	testData := []byte(`{
		"events": [
			{
				"tStartMs": "0",
				"dDurationMs": "2000",
				"segs": [
					{"utf8": "Hello"},
					{"utf8": " world"}
				]
			},
			{
				"tStartMs": "2000",
				"dDurationMs": "3000",
				"segs": [
					{"utf8": "How are you?"}
				]
			}
		]
	}`)

	entries, err := client.parseTimedtext(testData)
	if err != nil {
		t.Fatalf("parseTimedtext failed: %v", err)
	}

	if len(entries) != 2 {
		t.Errorf("parseTimedtext returned %d entries, want 2", len(entries))
	}

	// Check first entry
	if entries[0].Start != 0.0 {
		t.Errorf("Entry 0 Start = %v, want 0.0", entries[0].Start)
	}
	if entries[0].Duration != 2.0 {
		t.Errorf("Entry 0 Duration = %v, want 2.0", entries[0].Duration)
	}
	if entries[0].Text != "Hello world" {
		t.Errorf("Entry 0 Text = %q, want %q", entries[0].Text, "Hello world")
	}

	// Check second entry
	if entries[1].Start != 2.0 {
		t.Errorf("Entry 1 Start = %v, want 2.0", entries[1].Start)
	}
	if entries[1].Duration != 3.0 {
		t.Errorf("Entry 1 Duration = %v, want 3.0", entries[1].Duration)
	}
	if entries[1].Text != "How are you?" {
		t.Errorf("Entry 1 Text = %q, want %q", entries[1].Text, "How are you?")
	}
}

func TestParseTimedtext_EmptyResponse(t *testing.T) {
	client := NewTimedtextClient()
	defer client.Close()

	testData := []byte(`{"events": []}`)

	entries, err := client.parseTimedtext(testData)
	if err != nil {
		t.Fatalf("parseTimedtext failed: %v", err)
	}

	if len(entries) != 0 {
		t.Errorf("parseTimedtext returned %d entries, want 0", len(entries))
	}
}

func TestParseTimedtext_InvalidJSON(t *testing.T) {
	client := NewTimedtextClient()
	defer client.Close()

	testData := []byte(`invalid json`)

	_, err := client.parseTimedtext(testData)
	if err == nil {
		t.Fatal("parseTimedtext should fail on invalid JSON")
	}
}

func TestExtractLanguagesFromResponse(t *testing.T) {
	client := NewTimedtextClient()
	defer client.Close()

	testData := []byte(`{"events": []}`)

	languages, err := client.extractLanguagesFromResponse(testData)
	if err != nil {
		t.Fatalf("extractLanguagesFromResponse failed: %v", err)
	}

	// Currently returns empty list - language detection requires video page parsing
	if len(languages) != 0 {
		t.Errorf("extractLanguagesFromResponse returned %d languages, want 0", len(languages))
	}
}

func TestFetchCaptions_EmptyVideoID(t *testing.T) {
	client := NewTimedtextClient()
	defer client.Close()

	ctx := context.Background()
	_, err := client.FetchCaptions(ctx, "", "en")
	if err == nil {
		t.Fatal("FetchCaptions should fail with empty video ID")
	}
}

func TestListAvailableLanguages_EmptyVideoID(t *testing.T) {
	client := NewTimedtextClient()
	defer client.Close()

	ctx := context.Background()
	_, err := client.ListAvailableLanguages(ctx, "")
	if err == nil {
		t.Fatal("ListAvailableLanguages should fail with empty video ID")
	}
}

func TestTimedtextClientClose(t *testing.T) {
	client := NewTimedtextClient()
	if err := client.Close(); err != nil {
		t.Errorf("Close failed: %v", err)
	}
}

func TestLanguageInfo(t *testing.T) {
	lang := LanguageInfo{
		Code:            "en",
		Name:            "English",
		IsAutoGenerated: false,
	}

	if lang.Code != "en" {
		t.Errorf("Code = %s, want en", lang.Code)
	}
	if lang.Name != "English" {
		t.Errorf("Name = %s, want English", lang.Name)
	}
	if lang.IsAutoGenerated {
		t.Error("IsAutoGenerated should be false")
	}
}
