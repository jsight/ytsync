package youtube

import (
	"testing"
	"time"
)

// TestYtdlpVsDirectAPIConsistency tests that yt-dlp and direct timedtext API
// produce consistent transcript data when both are available.
func TestYtdlpVsDirectAPIConsistency(t *testing.T) {
	// This test demonstrates the expected consistency between extraction methods.
	// In production, this would test against actual YouTube videos.

	// Simulate yt-dlp output
	ytdlpEntries := []TranscriptEntry{
		{Start: 0.0, Duration: 2.5, Text: "First caption"},
		{Start: 2.5, Duration: 1.75, Text: "Second caption"},
		{Start: 4.25, Duration: 3.0, Text: "Third caption"},
	}

	// Simulate direct API output (should be identical)
	directEntries := []TranscriptEntry{
		{Start: 0.0, Duration: 2.5, Text: "First caption"},
		{Start: 2.5, Duration: 1.75, Text: "Second caption"},
		{Start: 4.25, Duration: 3.0, Text: "Third caption"},
	}

	// Verify consistency
	if len(ytdlpEntries) != len(directEntries) {
		t.Errorf("Entry count mismatch: yt-dlp=%d, direct=%d", len(ytdlpEntries), len(directEntries))
	}

	for i := range ytdlpEntries {
		if ytdlpEntries[i].Text != directEntries[i].Text {
			t.Errorf("Entry %d text mismatch: %q vs %q", i, ytdlpEntries[i].Text, directEntries[i].Text)
		}
		if ytdlpEntries[i].Start != directEntries[i].Start {
			t.Errorf("Entry %d start time mismatch: %f vs %f", i, ytdlpEntries[i].Start, directEntries[i].Start)
		}
		if ytdlpEntries[i].Duration != directEntries[i].Duration {
			t.Errorf("Entry %d duration mismatch: %f vs %f", i, ytdlpEntries[i].Duration, directEntries[i].Duration)
		}
	}
}

// TestDirectAPIFallbackBehavior tests the fallback mechanism when yt-dlp is unavailable.
func TestDirectAPIFallbackBehavior(t *testing.T) {
	// Create mock extractor with both yt-dlp and direct API available
	extractor := NewTranscriptExtractor()

	// In real scenario, this would use the yt-dlp path
	// For testing, we verify the extractor can be configured
	if extractor.path() == "" {
		t.Error("Extractor should have a valid yt-dlp path")
	}

	// Test 2: Verify timedtext client can be used as fallback
	timedtextClient := NewTimedtextClient()
	defer timedtextClient.Close()

	if timedtextClient.httpClient == nil {
		t.Error("Timedtext client should have HTTP client initialized")
	}

	// Test 3: Language preference with fallback
	pref := LanguagePreference{
		PreferredLanguages:   []string{"en"},
		IncludeAutoGenerated: true,
		AllowEnglishFallback: true,
	}

	if len(pref.PreferredLanguages) == 0 {
		t.Error("Language preference should have preferred languages")
	}
}

// TestTranscriptExtractionMethodComparison tests key differences and similarities
// between extraction methods.
func TestTranscriptExtractionMethodComparison(t *testing.T) {
	// Create two converters with same data to compare format outputs
	entries := []TranscriptEntry{
		{Start: 0.0, Duration: 2.5, Text: "Test caption"},
		{Start: 2.5, Duration: 1.5, Text: "Another caption"},
	}

	converter := NewFormatConverter(entries)

	// Test 1: Both methods should support multiple formats
	formats := []Format{
		FormatJSON3,
		FormatVTT,
		FormatSRT,
	}

	for _, format := range formats {
		output, err := converter.ToFormat(format)
		if err != nil {
			t.Errorf("Format %s conversion failed: %v", format, err)
		}
		if output == "" {
			t.Errorf("Format %s returned empty output", format)
		}
	}

	// Test 2: Both methods should preserve timing accuracy
	json3Output, _ := converter.ToFormat(FormatJSON3)
	vttOutput, _ := converter.ToFormat(FormatVTT)

	// JSON3 uses milliseconds
	if !contains(json3Output, "2500") {
		t.Error("JSON3 should preserve millisecond timing")
	}

	// VTT uses centisecond format
	if !contains(vttOutput, "00:00:02.5") || !contains(vttOutput, "00:00:00.0") {
		t.Error("VTT should have proper timing format")
	}

	// Test 3: Both methods should support language selection
	la := NewLanguageAvailability("test-video")
	la.Update(
		[]LanguageInfo{{Code: "en", Name: "English"}},
		[]LanguageInfo{},
	)

	selector := NewLanguageSelector(DefaultLanguagePreference())
	lang, _, err := selector.Select("test-video", la)
	if err != nil {
		t.Errorf("Language selection failed: %v", err)
	}
	if lang != "en" {
		t.Errorf("Language selection returned %s, want en", lang)
	}
}

// TestYtdlpDataCompleteness tests that yt-dlp extraction provides complete data.
func TestYtdlpDataCompleteness(t *testing.T) {
	// Create test data simulating yt-dlp output
	entries := []TranscriptEntry{
		{Start: 0.0, Duration: 2.0, Text: "Line 1"},
		{Start: 2.0, Duration: 2.0, Text: "Line 2"},
		{Start: 4.0, Duration: 2.0, Text: "Line 3"},
	}

	// Verify all required fields are present
	for i, entry := range entries {
		if entry.Text == "" {
			t.Errorf("Entry %d missing text", i)
		}
		if entry.Start < 0 {
			t.Errorf("Entry %d has negative start time", i)
		}
		if entry.Duration <= 0 {
			t.Errorf("Entry %d has invalid duration", i)
		}
	}

	// Verify entries are in chronological order
	for i := 1; i < len(entries); i++ {
		prevEnd := entries[i-1].Start + entries[i-1].Duration
		currStart := entries[i].Start
		if currStart < prevEnd {
			t.Errorf("Entries %d and %d overlap", i-1, i)
		}
	}
}

// TestDirectAPIDataCompleteness tests that direct API extraction is complete.
func TestDirectAPIDataCompleteness(t *testing.T) {
	client := NewTimedtextClient()
	defer client.Close()

	// Test parsing of simulated timedtext response
	testData := []byte(`{
		"events": [
			{"tStartMs": "0", "dDurationMs": "2000", "segs": [{"utf8": "Line 1"}]},
			{"tStartMs": "2000", "dDurationMs": "2000", "segs": [{"utf8": "Line 2"}]},
			{"tStartMs": "4000", "dDurationMs": "2000", "segs": [{"utf8": "Line 3"}]}
		]
	}`)

	entries, err := client.parseTimedtext(testData)
	if err != nil {
		t.Fatalf("parseTimedtext failed: %v", err)
	}

	// Verify completeness
	if len(entries) != 3 {
		t.Errorf("parseTimedtext returned %d entries, want 3", len(entries))
	}

	for i, entry := range entries {
		if entry.Text == "" {
			t.Errorf("Entry %d missing text", i)
		}
		if entry.Duration <= 0 {
			t.Errorf("Entry %d has invalid duration", i)
		}
	}
}

// TestTranscriptExtractionMethodSwitching tests switching between extraction methods.
func TestTranscriptExtractionMethodSwitching(t *testing.T) {
	// Simulate having both methods available
	ytdlpExtractor := NewTranscriptExtractor()
	timedtextClient := NewTimedtextClient()
	defer timedtextClient.Close()

	// Verify both can be instantiated
	if ytdlpExtractor == nil {
		t.Fatal("Failed to create yt-dlp extractor")
	}
	if timedtextClient == nil {
		t.Fatal("Failed to create timedtext client")
	}

	// Test: Data format compatibility
	// Both should produce data that can be converted to same formats
	entries := []TranscriptEntry{
		{Start: 0, Duration: 1, Text: "Test"},
	}

	converter := NewFormatConverter(entries)

	// Both yt-dlp and direct API results should be convertible
	formats := []Format{FormatJSON3, FormatVTT, FormatSRT, FormatJSON}

	for _, format := range formats {
		output, err := converter.ToFormat(format)
		if err != nil {
			t.Errorf("Failed to convert to %s: %v", format, err)
		}
		if output == "" {
			t.Errorf("Empty output for format %s", format)
		}
	}
}

// TestExtractionMethodPerformanceCharacteristics tests the expected performance
// characteristics of both extraction methods.
func TestExtractionMethodPerformanceCharacteristics(t *testing.T) {
	// Simulate timing measurements
	// (In real scenario, would use benchmarking)

	// Test data processing speed
	largeTranscript := make([]TranscriptEntry, 1000)
	for i := 0; i < 1000; i++ {
		largeTranscript[i] = TranscriptEntry{
			Start:    float64(i),
			Duration: 1.0,
			Text:     "Caption line",
		}
	}

	converter := NewFormatConverter(largeTranscript)

	// All conversions should complete quickly even with large transcripts
	formats := []Format{FormatJSON3, FormatJSON, FormatVTT, FormatSRT, FormatTTML}

	for _, format := range formats {
		start := time.Now()
		output, err := converter.ToFormat(format)
		duration := time.Since(start)

		if err != nil {
			t.Errorf("Format %s failed: %v", format, err)
		}

		// Large transcript conversion should be fast (< 100ms)
		if duration > 100*time.Millisecond {
			t.Logf("Format %s conversion took %v (may be slow)", format, duration)
		}

		if output == "" {
			t.Errorf("Format %s returned empty for large transcript", format)
		}
	}
}

// TestLanguageAvailabilityFromBothSources tests that language availability
// can be determined from both extraction sources.
func TestLanguageAvailabilityFromBothSources(t *testing.T) {
	// Both yt-dlp and direct API should be able to determine available languages

	// Create language availability
	la := NewLanguageAvailability("test-video")

	// Simulate multiple languages available from both sources
	manual := []LanguageInfo{
		{Code: "en", Name: "English", IsAutoGenerated: false},
		{Code: "es", Name: "Spanish", IsAutoGenerated: false},
	}

	auto := []LanguageInfo{
		{Code: "fr", Name: "French", IsAutoGenerated: true},
		{Code: "de", Name: "German", IsAutoGenerated: true},
	}

	la.Update(manual, auto)

	// Both sources should respect the same selection logic
	pref := LanguagePreference{
		PreferredLanguages:   []string{"en", "es", "fr"},
		PreferManualCaptions: true,
		IncludeAutoGenerated: true,
	}

	lang, isAuto := la.SelectLanguage(pref)
	if lang != "en" {
		t.Errorf("Language selection returned %s, want en", lang)
	}
	if isAuto {
		t.Error("Should select manual English, not auto")
	}

	// Test fallback to auto-generated if not available manually
	la.Update([]LanguageInfo{}, auto)

	lang, isAuto = la.SelectLanguage(pref)
	if lang != "fr" || !isAuto {
		t.Errorf("Should fallback to auto-generated: got %s (auto=%v)", lang, isAuto)
	}
}

// Helper function to check if string contains substring
func contains(s, substr string) bool {
	return len(s) > 0 && len(substr) > 0 && indexOf(s, substr) >= 0
}

func indexOf(s, substr string) int {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return i
		}
	}
	return -1
}
