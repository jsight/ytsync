package youtube

import (
	"testing"
	"time"
)

func TestDefaultLanguagePreference(t *testing.T) {
	pref := DefaultLanguagePreference()
	if len(pref.PreferredLanguages) == 0 {
		t.Error("DefaultLanguagePreference should have preferred languages")
	}
	if !pref.IncludeAutoGenerated {
		t.Error("DefaultLanguagePreference should include auto-generated captions")
	}
	if !pref.AllowEnglishFallback {
		t.Error("DefaultLanguagePreference should allow English fallback")
	}
}

func TestNewLanguageAvailability(t *testing.T) {
	la := NewLanguageAvailability("test-video")
	if la.VideoID != "test-video" {
		t.Errorf("VideoID = %s, want test-video", la.VideoID)
	}
}

func TestLanguageAvailabilityUpdate(t *testing.T) {
	la := NewLanguageAvailability("test-video")

	manual := []LanguageInfo{
		{Code: "en", Name: "English", IsAutoGenerated: false},
	}
	auto := []LanguageInfo{
		{Code: "es", Name: "Spanish", IsAutoGenerated: true},
	}

	la.Update(manual, auto)

	if len(la.ManualLanguages) != 1 {
		t.Errorf("ManualLanguages count = %d, want 1", len(la.ManualLanguages))
	}
	if len(la.AutoLanguages) != 1 {
		t.Errorf("AutoLanguages count = %d, want 1", len(la.AutoLanguages))
	}
}

func TestSelectLanguage_PreferredLanguageAvailable(t *testing.T) {
	la := NewLanguageAvailability("test-video")
	la.Update(
		[]LanguageInfo{{Code: "en", Name: "English"}},
		[]LanguageInfo{},
	)

	pref := LanguagePreference{
		PreferredLanguages:   []string{"en", "es"},
		IncludeAutoGenerated: false,
	}

	lang, isAuto := la.SelectLanguage(pref)
	if lang != "en" {
		t.Errorf("SelectLanguage returned %s, want en", lang)
	}
	if isAuto {
		t.Error("SelectLanguage should return isAuto=false for manual captions")
	}
}

func TestSelectLanguage_FallbackToEnglish(t *testing.T) {
	la := NewLanguageAvailability("test-video")
	la.Update(
		[]LanguageInfo{{Code: "en", Name: "English"}},
		[]LanguageInfo{},
	)

	pref := LanguagePreference{
		PreferredLanguages:   []string{"fr"},
		AllowEnglishFallback: true,
	}

	lang, _ := la.SelectLanguage(pref)
	if lang != "en" {
		t.Errorf("SelectLanguage should fallback to English, got %s", lang)
	}
}

func TestSelectLanguage_PreferManualCaptions(t *testing.T) {
	la := NewLanguageAvailability("test-video")
	la.Update(
		[]LanguageInfo{{Code: "en", Name: "English"}},
		[]LanguageInfo{{Code: "en", Name: "English (auto)"}},
	)

	pref := LanguagePreference{
		PreferredLanguages:   []string{"en"},
		PreferManualCaptions: true,
		IncludeAutoGenerated: true,
	}

	lang, isAuto := la.SelectLanguage(pref)
	if lang != "en" {
		t.Errorf("SelectLanguage returned %s, want en", lang)
	}
	if isAuto {
		t.Error("SelectLanguage should prefer manual captions")
	}
}

func TestSelectLanguage_AutoGeneratedFallback(t *testing.T) {
	la := NewLanguageAvailability("test-video")
	la.Update(
		[]LanguageInfo{},
		[]LanguageInfo{{Code: "en", Name: "English (auto)"}},
	)

	pref := LanguagePreference{
		PreferredLanguages:   []string{"en"},
		IncludeAutoGenerated: true,
	}

	lang, isAuto := la.SelectLanguage(pref)
	if lang != "en" {
		t.Errorf("SelectLanguage returned %s, want en", lang)
	}
	if !isAuto {
		t.Error("SelectLanguage should return isAuto=true for auto-generated captions")
	}
}

func TestSelectLanguage_NoLanguageAvailable(t *testing.T) {
	la := NewLanguageAvailability("test-video")
	la.Update([]LanguageInfo{}, []LanguageInfo{})

	pref := DefaultLanguagePreference()
	lang, _ := la.SelectLanguage(pref)
	if lang != "" {
		t.Errorf("SelectLanguage should return empty string when no languages available, got %s", lang)
	}
}

func TestGetAllLanguages(t *testing.T) {
	la := NewLanguageAvailability("test-video")
	la.Update(
		[]LanguageInfo{
			{Code: "en", Name: "English"},
			{Code: "es", Name: "Spanish"},
		},
		[]LanguageInfo{
			{Code: "fr", Name: "French"},
		},
	)

	all := la.GetAllLanguages()
	if len(all) != 3 {
		t.Errorf("GetAllLanguages returned %d languages, want 3", len(all))
	}
}

func TestLanguageCacheSet_Get(t *testing.T) {
	cache := NewLanguageCache(1 * time.Hour)
	la := NewLanguageAvailability("test-video")
	la.Update([]LanguageInfo{{Code: "en", Name: "English"}}, []LanguageInfo{})

	cache.Set("test-video", la)

	retrieved := cache.Get("test-video")
	if retrieved == nil {
		t.Fatal("cache.Get returned nil")
	}
	if retrieved.VideoID != "test-video" {
		t.Errorf("Retrieved VideoID = %s, want test-video", retrieved.VideoID)
	}
}

func TestLanguageCacheMiss(t *testing.T) {
	cache := NewLanguageCache(1 * time.Hour)

	retrieved := cache.Get("nonexistent")
	if retrieved != nil {
		t.Error("cache.Get should return nil for nonexistent key")
	}
}

func TestLanguageCacheTTL(t *testing.T) {
	cache := NewLanguageCache(1 * time.Millisecond)
	la := NewLanguageAvailability("test-video")
	la.Update([]LanguageInfo{{Code: "en", Name: "English"}}, []LanguageInfo{})

	cache.Set("test-video", la)

	// Wait for cache to expire
	time.Sleep(5 * time.Millisecond)

	retrieved := cache.Get("test-video")
	if retrieved != nil {
		t.Error("cache.Get should return nil after TTL expires")
	}
}

func TestLanguageCacheNoTTL(t *testing.T) {
	cache := NewLanguageCache(0) // No TTL
	la := NewLanguageAvailability("test-video")
	la.Update([]LanguageInfo{{Code: "en", Name: "English"}}, []LanguageInfo{})

	cache.Set("test-video", la)

	// Wait a bit
	time.Sleep(1 * time.Millisecond)

	retrieved := cache.Get("test-video")
	if retrieved == nil {
		t.Error("cache.Get should not expire with TTL=0")
	}
}

func TestLanguageCacheClear(t *testing.T) {
	cache := NewLanguageCache(1 * time.Hour)
	la := NewLanguageAvailability("test-video")
	la.Update([]LanguageInfo{{Code: "en", Name: "English"}}, []LanguageInfo{})

	cache.Set("test-video", la)
	cache.Clear("test-video")

	retrieved := cache.Get("test-video")
	if retrieved != nil {
		t.Error("cache.Get should return nil after Clear")
	}
}

func TestLanguageCacheClearAll(t *testing.T) {
	cache := NewLanguageCache(1 * time.Hour)

	for i := 1; i <= 3; i++ {
		videoID := "video-" + string(rune(i))
		la := NewLanguageAvailability(videoID)
		la.Update([]LanguageInfo{{Code: "en", Name: "English"}}, []LanguageInfo{})
		cache.Set(videoID, la)
	}

	if cache.Size() != 3 {
		t.Errorf("Cache size = %d, want 3", cache.Size())
	}

	cache.ClearAll()

	if cache.Size() != 0 {
		t.Errorf("Cache size after ClearAll = %d, want 0", cache.Size())
	}
}

func TestLanguageSelector(t *testing.T) {
	pref := DefaultLanguagePreference()
	selector := NewLanguageSelector(pref)

	la := NewLanguageAvailability("test-video")
	la.Update(
		[]LanguageInfo{{Code: "en", Name: "English"}},
		[]LanguageInfo{},
	)

	lang, isAuto, err := selector.Select("test-video", la)
	if err != nil {
		t.Fatalf("Select failed: %v", err)
	}
	if lang != "en" {
		t.Errorf("Select returned %s, want en", lang)
	}
	if isAuto {
		t.Error("Select should return isAuto=false")
	}
}

func TestLanguageSelectorEmptyVideoID(t *testing.T) {
	selector := NewLanguageSelector(DefaultLanguagePreference())
	_, _, err := selector.Select("", nil)
	if err == nil {
		t.Fatal("Select should fail with empty video ID")
	}
}

func TestLanguageSelectorNilAvailability(t *testing.T) {
	selector := NewLanguageSelector(DefaultLanguagePreference())
	_, _, err := selector.Select("test-video", nil)
	if err == nil {
		t.Fatal("Select should fail with nil availability")
	}
}

func TestGetLanguageInfo(t *testing.T) {
	info := GetLanguageInfo("en")
	if info.Code != "en" || info.Name != "English" {
		t.Errorf("GetLanguageInfo(en) = %+v, want {Code:en Name:English}", info)
	}

	// Unknown language
	info = GetLanguageInfo("xx")
	if info.Code != "xx" {
		t.Errorf("GetLanguageInfo(xx) = %+v, want {Code:xx Name:xx}", info)
	}
}

func TestLanguageInfoConstants(t *testing.T) {
	tests := []struct {
		langInfo LanguageInfo
		code     string
		name     string
	}{
		{LangEnglish, "en", "English"},
		{LangSpanish, "es", "Spanish"},
		{LangFrench, "fr", "French"},
		{LangJapanese, "ja", "Japanese"},
	}

	for _, tt := range tests {
		if tt.langInfo.Code != tt.code || tt.langInfo.Name != tt.name {
			t.Errorf("Language constant = %+v, want {Code:%s Name:%s}", tt.langInfo, tt.code, tt.name)
		}
	}
}
